{"version":3,"file":"index.cjs","names":["result: Record<string, any>","keyPaths: Record<string, any>","util","getValues","values","collection: GenericObj","list: T[]","result: any[]","valuesToDiff: T[] | Item[]","diffValues: any","items: Item[] | [string, Item][]","kv: GenericObj","occuredValues: any[]","duplicateValues: GenericObj","collection: any[]","flat","intersectValues: Item[]","arrayOrObject: GenericObj","merged: GenericObj","values: any[]","isArray","arrays: [Collection<Item>, Collection<Item>]","keyMatches: any[]","valueMatches: any[]","reduceCarry: T | null | undefined","result: number | undefined","previous: boolean | null","callback: (v: Item) => any","ordered: GenericObj","childCollection: any[]","collection: Collection<Item> | Item[]","comparisonValue: Operator | V | K","items: any"],"sources":["../src/utilities/filters.ts","../src/utilities/is.ts","../src/utilities/buildKeyPathMap.ts","../src/utilities/clone.ts","../src/utilities/variadic.ts","../src/utilities/deleteKeys.ts","../src/utilities/values.ts","../src/utilities/nestedValue.ts","../src/collection.ts"],"sourcesContent":["\nexport function falsyValue<X> (item: X) {\n    if (Array.isArray(item)) {\n        if (item.length) {\n            return false\n        }\n    } else if (item !== undefined && item !== null\n        && typeof item === 'object') {\n        if (Object.keys(item).length) {\n            return false\n        }\n    } else if (item) {\n        return false\n    }\n\n    return true\n}\n\nexport function filterObject (func?: (...args: any[]) => any, items: Record<string, any> = {}) {\n    const result: Record<string, any> = {}\n    Object.keys(items).forEach((key) => {\n        if (func) {\n            if (func(items[key], key)) {\n                result[key] = items[key]\n            }\n        } else if (!falsyValue(items[key])) {\n            result[key] = items[key]\n        }\n    })\n\n    return result\n}\n\nexport function filterArray (func?: (...args: any[]) => any, items: Record<string, any> = {}) {\n    if (func) {\n        return items.filter(func)\n    }\n    const result = []\n    for (let i = 0; i < items.length; i += 1) {\n        const item = items[i]\n        if (!falsyValue(item)) {\n            result.push(item)\n        }\n    }\n\n    return result\n}","'use strict'\n\ntype X = any\n\nexport const isArray = <K> (item: X): item is K[] => Array.isArray(item)\n\nexport const isObject = <K> (item: X): item is Record<string, K> => typeof item === 'object' && Array.isArray(item) === false && item !== null\n\nexport const isFunction = (item: X): item is ((...args: any[]) => any) => typeof item === 'function'\n","import { isArray, isObject } from './is'\n\nexport default function buildKeyPathMap<X> (items: X[]) {\n    const keyPaths: Record<string, any> = {}\n\n    items.forEach((item, index) => {\n        function buildKeyPath (val: any, keyPath: string) {\n            if (isObject(val)) {\n                Object.keys(val).forEach((prop) => {\n                    buildKeyPath(val[prop], `${keyPath}.${prop}`)\n                })\n            } else if (isArray(val)) {\n                val.forEach((v, i) => {\n                    buildKeyPath(v, `${keyPath}.${i}`)\n                })\n            }\n\n            keyPaths[keyPath] = val\n        }\n\n        buildKeyPath(item, String(index))\n    })\n\n    return keyPaths\n}","'use strict'\n\n/**\n * Clone helper\n *\n * Clone an array or object\n *\n * @param items\n */\nexport default function clone<X> (items: X[] | Record<string, X>) {\n  if (Array.isArray(items)) {\n    return [...items]\n  } else {\n    return { ...items }\n  }\n}\n","'use strict'\n\n/**\n * Variadic helper function\n *\n * @param args\n */\nexport default function variadic (args: any[]) {\n  if (Array.isArray(args[0])) {\n    return args[0]\n  }\n\n  return args\n}\n","'use strict'\n\nimport variadic from './variadic'\n\n/**\n * Delete keys helper\n *\n * Delete one or multiple keys from an object\n *\n * @param obj\n * @param keys\n */\nexport default function deleteKeys<X extends Record<string, any> = any> (obj: X, ...keys: any[]) {\n  variadic(keys).forEach((key) => {\n    delete obj[key]\n  })\n}\n","'use strict'\n\nimport util from 'node:util'\n\n/**\n * Values helper\n *\n * Retrieve values from [this.items] when it is an array, object or Collection\n *\n * @param items\n */\nexport default function values<X> (items: X[] | (abstract new () => any) | Record<string, X>) {\n  const valuesArray = []\n\n  if (Array.isArray(items)) {\n    valuesArray.push(...items)\n  } else if (items.constructor.name === 'Collection') {\n    valuesArray.push(...(items as any).all())\n  } else if (typeof items === 'object') {\n    valuesArray.push(...Object.values(items))\n  }\n\n  return valuesArray\n}\n\nexport const inspect = (thing: any) => {\n  return util.inspect(thing, {\n    showHidden: false,\n    depth: 2,\n    colors: true,\n    compact: true\n  })\n}","'use strict'\n\n/**\n * Get value of a nested property\n *\n * @param mainObject\n * @param key\n */\nexport default function nestedValue (mainObject: any, key: any) {\n  try {\n    return key.split('.').reduce((obj: any, property: any) => obj[property], mainObject)\n  } catch {\n    // If we end up here, we're not working with an object, and @var mainObject is the value itself\n    return mainObject\n  }\n}\n","'use strict'\n\nimport { filterArray, filterObject } from './utilities/filters'\nimport { isArray, isFunction, isObject } from './utilities/is'\n\nimport buildKeyPathMap from './utilities/buildKeyPathMap'\nimport clone from './utilities/clone'\nimport deleteKeys from './utilities/deleteKeys'\nimport getValues, { inspect } from './utilities/values'\nimport nestedValue from './utilities/nestedValue'\nimport variadic from './utilities/variadic'\n\ntype Operator = '===' | '==' | '!==' | '!=' | '<>' | '>' | '<' | '>=' | '<=' | boolean\ntype GenericObj<X = any> = Record<string, X>\n\nexport class Collection<Item = any> {\n    private items: Item[]\n\n    /**\n     * \n     * @param collection \n     */\n    constructor(collection?: Record<string, Item> | Item[] | Item) {\n        if (collection !== undefined && !Array.isArray(collection) && typeof collection !== 'object') {\n            this.items = [collection]\n        } else if (collection instanceof Collection) {\n            this.items = collection.all()\n        } else {\n            this.items = (collection as Item[]) || []\n        }\n\n    };\n\n    /**\n     * The add method adds a single item to the collection.\n     */\n    add (item: Item): this {\n        this.items.push(item)\n\n        return this\n    }\n\n    /**\n     * The all method returns the underlying array represented by the collection.\n     */\n    all (): Item[] {\n        return this.items as never\n    }\n\n    /**\n     * Alias for the avg() method.\n     */\n    average (key?: keyof Item | ((p: Item) => any)): number {\n        return this.avg(key)\n    }\n\n    /**\n     * The avg method returns the average of all items in the collection.\n     */\n    avg (key?: keyof Item | ((p: Item) => any)): number {\n        if (!Array.isArray(this.items)) return 0\n\n        if (typeof key === 'undefined') {\n            return this.sum() / this.items.length\n        }\n\n        if (isFunction(key)) {\n            return new Collection(this.items).sum(key) / this.items.length\n        }\n\n        return new Collection(this.items).pluck(key).sum() / this.items.length\n    }\n\n    /**\n     * The chunk method breaks the collection into multiple, smaller collections of a given size.\n     */\n    chunk (size: number): Collection<Item[]> {\n        const chunks = []\n        let index = 0\n\n        if (Array.isArray(this.items)) {\n            do {\n                const items = this.items.slice(index, index + size)\n                const collection = new Collection(items)\n\n                chunks.push(collection)\n                index += size\n            } while (index < this.items.length)\n        } else if (typeof this.items === 'object') {\n            const keys = Object.keys(this.items)\n\n            do {\n                const keysOfChunk = keys.slice(index, index + size)\n                const collection = new Collection({})\n\n                keysOfChunk.forEach(key => collection.put(key, this.items[key as never]))\n\n                chunks.push(collection)\n                index += size\n            } while (index < keys.length)\n        } else {\n            chunks.push(new Collection([this.items]))\n        }\n\n        return new Collection(chunks) as never\n    }\n\n    /**\n     * The collapse method collapses a collection of arrays into a single, flat collection.\n     */\n    collapse (): Collection<Item> {\n        return new Collection<Item>([].concat(...getValues(this.items)))\n    }\n\n    /**\n     * The combine method combines the keys of the collection with the values of another array or collection.\n     */\n    combine<T, U> (array: U[] | Collection): Collection<T> {\n        let values = array\n\n        if (values instanceof Collection) {\n            values = array instanceof Collection ? array.all() as U[] : array\n        }\n\n        const collection: GenericObj = {}\n\n        if (Array.isArray(this.items) && Array.isArray(values)) {\n            this.items.forEach((key, iterator) => {\n                collection[key as never] = values[iterator]\n            })\n        } else if (typeof this.items === 'object' && typeof values === 'object') {\n            Object.keys(this.items).forEach((key, index) => {\n                collection[this.items[key as never] as never] = values[Object.keys(values)[index as number] as never]\n            })\n        } else if (Array.isArray(this.items)) {\n            collection[this.items[0] as never] = values\n        } else if (typeof this.items === 'string' && Array.isArray(values)) {\n            [collection[this.items]] = values\n        } else if (typeof this.items === 'string') {\n            collection[this.items] = values\n        }\n\n        return new Collection(collection)\n    }\n\n\n    /**\n     * The concat method is used to merge two or more collections/arrays/objects.\n     */\n    concat<T> (collectionOrArrayOrObject: T[] | Record<string, T> | Collection<T>): any {\n        let list: T[]\n\n        if (collectionOrArrayOrObject instanceof Collection) {\n            list = collectionOrArrayOrObject.all() as T[]\n        } else if (Array.isArray(collectionOrArrayOrObject)) {\n            list = collectionOrArrayOrObject\n        } else {\n            list = [...Object.values(collectionOrArrayOrObject)]\n        }\n\n        const collection = new Collection(clone(this.items))\n\n        list.forEach((item) => {\n            if (isObject(item)) {\n                Object.keys(item).forEach(key => collection.push(item[key as never] as never))\n            } else {\n                collection.push(item as never)\n            }\n        })\n\n        return collection\n    }\n\n\n    /**\n     * The contains method determines whether the collection contains a given item.\n     * \n     * @param key \n     * @param value \n     * @returns \n     */\n    contains<K, V> (key: keyof Item | K | ((...args: any[]) => any), value?: V): boolean {\n        if (typeof value !== 'undefined') {\n            if (Array.isArray(this.items)) {\n                return this.items\n                    .filter(items => (items as any)[key] !== undefined && (items as any)[key] === value)\n                    .length > 0\n            }\n\n            return (this.items as any)[key] !== undefined && (this.items as any)[key] === value\n        }\n\n        if (isFunction(key)) {\n            if (Array.isArray(this.items)) {\n                return this.items.filter((item, index) => key(item, index)).length > 0\n            }\n\n            return Object.entries(this.items).filter((item, index) => key(item, index)).length > 0\n        }\n\n        if (Array.isArray(this.items)) {\n            return this.items.indexOf(key as never) !== -1\n        }\n\n        const keysAndValues = getValues(this.items)\n        keysAndValues.push(...Object.keys(this.items))\n\n        return keysAndValues.indexOf(key) !== -1\n    }\n\n    /**\n     * Check to ensure the collection only contains one item\n     * \n     * @returns \n     */\n    containsOneItem () {\n        return this.count() === 1\n    }\n\n    /**\n     * The count method returns the total number of items in the collection.\n     */\n    count (): number {\n        let arrayLength = 0\n\n        if (Array.isArray(this.items)) {\n            arrayLength = this.items.length\n        }\n\n        return Math.max(Object.keys(this.items).length, arrayLength)\n    }\n\n    /**\n     * \n     * @param fn \n     * @returns \n     */\n    countBy (fn: ((value: Item) => any) = value => value): Collection<number> {\n        return new Collection<Item>(this.items)\n            .groupBy(fn)\n            .map((value: any) => value.count())\n    }\n\n    /**\n     * The crossJoin method cross joins the collection with the given array or collection, returning all possible permutations.\n     */\n    crossJoin<T> (...values: (T[] | Collection)[]): Collection<[Item, T]> {\n        function join (collection: any[], ...args: any[]) {\n            let current = args[0]\n\n            if (current instanceof Collection) {\n                current = current.all()\n            }\n\n            const rest = args.slice(1)\n            const last = !rest.length\n            let result: any[] = []\n\n            for (let i = 0; i < current.length; i += 1) {\n                const collectionCopy = collection.slice()\n                collectionCopy.push(current[i])\n\n                if (last) {\n                    result.push(collectionCopy)\n                } else {\n                    result = result.concat(join(collectionCopy, ...rest))\n                }\n            }\n\n            return result\n        }\n\n        return new Collection(join([], this.items, ...values))\n    }\n\n\n    /**\n     * The dd method will console.log the collection and exit the current process.\n     */\n    dd (...args: unknown[]): void {\n        this.dump(args)\n\n        if (typeof process !== 'undefined') {\n            process.exit(1)\n        }\n    }\n\n    /**\n     * The diff method compares the collection against another collection or a plain array based on its values.\n     * This method will return the values in the original collection that are not present in the given collection.\n     */\n    diff<T> (values: T[] | Collection<Item>): Collection<Item> {\n        let valuesToDiff: T[] | Item[]\n\n        if (values instanceof Collection) {\n            valuesToDiff = values.all()\n        } else {\n            valuesToDiff = values\n        }\n\n        const collection = this.items.filter(item => valuesToDiff.indexOf(item as never) === -1)\n\n        return new Collection(collection)\n    }\n\n\n    /**\n     * The diffAssoc method compares the collection against another collection or a plain object based on its keys\n     * and values. This method will return the key / value pairs in the original collection that are not present in\n     * the given collection:\n     */\n    diffAssoc<T> (values: T[] | Collection<T>): Collection<Item> {\n        let diffValues: any = values\n\n        if (values instanceof Collection) {\n            diffValues = values.all() as T[]\n        }\n\n        const collection: GenericObj = {}\n\n        Object.keys(this.items).forEach((key) => {\n            if (typeof diffValues[key] === 'undefined' || diffValues[key] !== (this.items as any)[key]) {\n                collection[key] = (this.items as any)[key]\n            }\n        })\n\n        return new Collection<Item>(collection)\n    }\n\n    /**\n     * The diffKeys method compares the collection against another collection or a plain object based on its keys.\n     * This method will return the key / value pairs in the original collection that are not present in the given collection.\n     * \n     * @param object \n     * @returns \n     */\n    diffKeys<K extends keyof Item> (object: object): Collection<K> {\n        let objectToDiff\n\n        if (object instanceof Collection) {\n            objectToDiff = object.all()\n        } else {\n            objectToDiff = object\n        }\n\n        const objectKeys = Object.keys(objectToDiff)\n\n        const remainingKeys = Object.keys(this.items)\n            .filter(item => objectKeys.indexOf(item) === -1)\n\n        return new Collection(this.items).only(remainingKeys) as never\n    }\n\n    /**\n     * The diffKeys method compares the collection against another collection or a plain object based on the result of a given callback.\n     * This method will return the key / value pairs in the original collection that are not present in the given collection.\n     * \n     * @param object \n     * @returns \n     */\n    diffUsing<T> (values: T[] | Collection<Item>, callback: (item: Item, otherItem: Item) => any) {\n        let items: Item[] | [string, Item][]\n\n        if (Array.isArray(this.items)) {\n            items = this.items\n        } else {\n            items = Object.entries(this.items)\n        }\n\n        const collection = items.filter(item => (\n            !(values && values.some((otherItem: any) => callback(Array.isArray(item) ? item[1] : item, otherItem) === 0))\n        ))\n\n        return new Collection<Item>(collection as never)\n    }\n\n\n    /**\n     * The doesntContain method determines whether the collection doesnt contain a given item.\n     * \n     * @param key \n     * @param value \n     * @returns \n     */\n    doesntContain<V> (key: keyof Item | ((...args: any[]) => any), value?: V): boolean {\n        return !this.contains(key, value)\n    }\n\n    /**\n     * The dot method allows accessing objects using the dot notation.\n     */\n    dot (): this {\n        if (!isObject(this.items)) {\n            return this\n        }\n\n        const sep = '.'\n        const kv: GenericObj = {}\n\n        const stringify = <X extends object> (obj: X, prev?: string) => {\n            const entries = Object.entries(obj)\n            for (let i = 0; i < entries.length; i += 1) {\n                const [k, v] = entries[i]\n                let key = k\n                if (prev) {\n                    key = prev + sep + key\n                }\n\n                if (isObject(v)) {\n                    stringify(v, key)\n                } else {\n                    kv[key] = v\n                }\n            }\n        }\n\n        stringify(this.items)\n\n        return new Collection(kv) as never\n    }\n\n    /**\n     * The dump method outputs the results at that moment and then continues processing.\n     */\n    dump (...args: unknown[]): this {\n        console.log(inspect(this))\n        args.forEach((thing) => {\n            console.log(inspect(thing))\n        })\n\n        return this\n    }\n\n    /**\n     * The duplicates method will find and return all duplicate properties in a collection\n     * \n     * @returns \n     */\n    duplicates (): Collection<Item> {\n        const occuredValues: any[] = []\n        const duplicateValues: GenericObj = {}\n\n        const stringifiedValue = (value: any) => {\n            if (Array.isArray(value) || typeof value === 'object') {\n                return JSON.stringify(value)\n            }\n\n            return value\n        }\n\n        if (Array.isArray(this.items)) {\n            this.items.forEach((value, index) => {\n                const valueAsString = stringifiedValue(value)\n\n                if (occuredValues.indexOf(valueAsString) === -1) {\n                    occuredValues.push(valueAsString)\n                } else {\n                    duplicateValues[index] = value\n                }\n            })\n        } else if (typeof this.items === 'object') {\n            Object.keys(this.items).forEach((key) => {\n                const valueAsString = stringifiedValue(this.items[key as never])\n\n                if (occuredValues.indexOf(valueAsString) === -1) {\n                    occuredValues.push(valueAsString)\n                } else {\n                    duplicateValues[key] = this.items[key as never]\n                }\n            })\n        }\n\n        return new Collection<Item>(duplicateValues)\n    }\n\n    /**\n     * The each method iterates over the items in the collection and passes each item to a callback.\n     */\n    each (fn: (currentItem: Item, key?: string | number, collection?: Item[]) => any): this {\n        let stop = false\n\n        if (Array.isArray(this.items)) {\n            const { length } = this.items\n\n            for (let index = 0; index < length && !stop; index += 1) {\n                stop = fn(this.items[index], index, this.items) === false\n            }\n        } else {\n            const keys = Object.keys(this.items)\n            const { length } = keys\n\n            for (let index = 0; index < length && !stop; index += 1) {\n                const key = keys[index]\n\n                stop = fn(this.items[key as never], key, this.items as never) === false\n            }\n        }\n\n        return this\n    }\n\n    /**\n     * \n     * @param fn \n     * @returns \n     */\n    eachSpread (fn: (...items: any[]) => any) {\n        this.each((values: any, key) => {\n            fn(...values, key)\n        })\n\n        return this\n    }\n\n    /**\n     * The every method may be used to verify that all elements of a collection pass a given truth test.\n     */\n    every (fn: (item: Item) => boolean): boolean {\n        const items = getValues(this.items)\n\n        return items.every(fn)\n    }\n\n\n    /**\n     * The except method returns all items in the collection except for those with the specified keys.\n     */\n    except<K> (...args: K[]): Collection<Item> {\n        const properties = variadic(args)\n\n        if (Array.isArray(this.items)) {\n            const collection = this.items\n                .filter(item => properties.indexOf(item) === -1)\n\n            return new Collection(collection)\n        }\n\n        const collection: GenericObj = {}\n\n        Object.keys(this.items).forEach((property) => {\n            if (properties.indexOf(property) === -1) {\n                collection[property] = this.items[property as never]\n            }\n        })\n\n        return new Collection(collection)\n    }\n\n    /**\n     * The filter method filters the collection using the given callback,\n     * keeping only those items that pass a given truth test.\n     */\n    filter (fn: (item: Item) => boolean): Collection<Item>;\n    filter (fn: (item: Item, key?: any) => boolean): Collection<Item> {\n        const func = fn || false\n        let filteredItems = null\n        if (Array.isArray(this.items)) {\n            filteredItems = filterArray(func, this.items)\n        } else {\n            filteredItems = filterObject(func, this.items)\n        }\n\n        return new Collection(filteredItems)\n    }\n\n    /**\n     * The first method returns the first element in the collection that passes a given truth test.\n     */\n    first<V> (fn?: (item: Item, key: any) => boolean, defaultValue?: ((...any: any[]) => V | Item) | V | Item): Collection<Item> | undefined {\n        if (isFunction(fn)) {\n            const keys = Object.keys(this.items)\n\n            for (let i = 0; i < keys.length; i += 1) {\n                const key = keys[i]\n                const item = this.items[key as never]\n\n                if (fn(item, key)) {\n                    return item as never\n                }\n            }\n\n            if (isFunction(defaultValue)) {\n                return defaultValue() as never\n            }\n\n            return defaultValue as never\n        }\n\n        if ((Array.isArray(this.items) && this.items.length) || (Object.keys(this.items).length)) {\n            if (Array.isArray(this.items)) {\n                return this.items[0] as never\n            }\n\n            const firstKey = Object.keys(this.items)[0]\n\n            return this.items[firstKey] as never\n        }\n\n        if (isFunction(defaultValue)) {\n            return defaultValue() as never\n        }\n\n        return defaultValue as never\n    }\n\n    /**\n     * \n     * @param key \n     * @param operator \n     * @param value \n     * @returns \n     */\n    firstOrFail<V> (key?: keyof Item, operator?: Operator, value?: V | null | undefined) {\n        if (isFunction(key)) {\n            return this.first(key, () => {\n                throw new Error('Item not found.')\n            }) as never\n        }\n\n        const collection = this.where(key, operator, value)\n\n        if (collection.isEmpty()) {\n            throw new Error('Item not found.')\n        }\n\n        return collection.first()\n    }\n\n    /**\n     * \n     * @param key \n     * @param operator \n     * @param value \n     * @returns \n     */\n    firstWhere<K, V> (key?: keyof Item, operator?: Operator | K, value?: V | null | undefined) {\n        return this.where(key, operator, value).first()\n    }\n\n    /**\n     * The flatMap method iterates through the collection and passes each value to the given callback.\n     * The callback is free to modify the item and return it, thus forming a new collection of modified items.\n     * Then, the array is flattened by a level.\n     */\n    flatMap<T> (fn: (item: Item, key: any) => T): Collection<T> {\n        return this.map(fn).collapse()\n    }\n\n    /**\n     * The flatten method flattens a multi-dimensional collection into a single dimension.\n     */\n    flatten (depth?: number): Collection<Item> {\n        let flattenDepth = depth || Infinity\n\n        let fullyFlattened = false\n        let collection: any[] = []\n\n        const flat = function flat (items: any) {\n            collection = []\n\n            if (isArray(items)) {\n                items.forEach((item) => {\n                    if (isArray(item)) {\n                        collection = collection.concat(item)\n                    } else if (isObject(item)) {\n                        Object.keys(item).forEach((property) => {\n                            collection = collection.concat(item[property])\n                        })\n                    } else {\n                        collection.push(item)\n                    }\n                })\n            } else {\n                Object.keys(items).forEach((property) => {\n                    if (isArray(items[property])) {\n                        collection = collection.concat(items[property])\n                    } else if (isObject(items[property])) {\n                        Object.keys(items[property]).forEach((prop) => {\n                            collection = collection.concat(items[property][prop])\n                        })\n                    } else {\n                        collection.push(items[property])\n                    }\n                })\n            }\n\n            fullyFlattened = collection.filter(item => isObject(item)).length === 0\n\n            flattenDepth -= 1\n        }\n\n        flat(this.items)\n\n        while (!fullyFlattened && flattenDepth > 0) {\n            flat(collection)\n        }\n\n        return new Collection(collection)\n    }\n\n    /**\n     * The flip method swaps the collection's keys with their corresponding values.\n     */\n    flip (): Collection<Item> {\n        const collection: GenericObj = {}\n\n        if (Array.isArray(this.items)) {\n            Object.keys(this.items).forEach((key) => {\n                collection[this.items[key as never] as never] = Number(key)\n            })\n        } else {\n            Object.keys(this.items).forEach((key) => {\n                collection[this.items[key as never] as never] = key\n            })\n        }\n\n        return new Collection(collection)\n    }\n\n\n    /**\n     * The forget method removes an item from the collection by its key.\n     */\n    forget<K> (key: keyof Item | K): this {\n        if (Array.isArray(this.items)) {\n            this.items.splice(key as never, 1)\n        } else {\n            delete this.items[key as never]\n        }\n\n        return this\n    }\n\n\n    /**\n     * The forPage method returns a new collection containing the items that would be present on a given page number.\n     * The method accepts the page number as its first argument\n     * and the number of items to show per page as its second argument.\n     */\n    forPage (page: number, chunk: number): Collection<Item> {\n        let collection: GenericObj = {}\n\n        if (Array.isArray(this.items)) {\n            collection = this.items.slice((page * chunk) - chunk, page * chunk)\n        } else {\n            Object\n                .keys(this.items)\n                .slice((page * chunk) - chunk, page * chunk)\n                .forEach((key) => {\n                    collection[key] = this.items[key as never]\n                })\n        }\n\n        return new Collection<Item>(collection)\n    }\n\n\n    /**\n     * The get method returns the item at a given key. If the key does not exist, null is returned.\n     */\n    get<K, V> (key: keyof Item | K, defaultValue?: ((...any: any[]) => V | Item) | V | Item) {\n        if (typeof this.items[key as never] !== 'undefined') {\n            return this.items[key as never]\n        }\n\n        if (isFunction(defaultValue)) {\n            return defaultValue()\n        }\n\n        if (defaultValue !== null) {\n            return defaultValue\n        }\n\n        return undefined\n    }\n\n    /**\n     * The groupBy method groups the collection's items by a given key.\n     *\n     */\n    groupBy<T, K> (key: ((item: Item, index?: number) => K) | keyof Item | K): Collection<T> {\n        const collection: GenericObj = {}\n\n        if (Array.isArray(this.items)) {\n            this.items.forEach((item, index) => {\n                let resolvedKey\n\n                if (isFunction(key)) {\n                    resolvedKey = key(item, index)\n                } else if (nestedValue(item, key as never) || nestedValue(item, key as never) === 0) {\n                    resolvedKey = nestedValue(item, key as never)\n                } else {\n                    resolvedKey = ''\n                }\n\n                if (collection[resolvedKey] === undefined) {\n                    collection[resolvedKey] = new Collection([])\n                }\n\n                collection[resolvedKey].push(item)\n            })\n        } else {\n            Object.keys(this.items).forEach((index) => {\n                let resolvedKey\n\n                if (isFunction(key)) {\n                    resolvedKey = key(this.items[index as never], index as never)\n                } else if (nestedValue(this.items[index as never], key as never) || nestedValue(this.items[index as never], key) === 0) {\n                    resolvedKey = nestedValue(this.items[index as never], key as never)\n                } else {\n                    resolvedKey = ''\n                }\n\n                if (collection[resolvedKey] === undefined) {\n                    collection[resolvedKey] = new Collection([])\n                }\n\n                collection[resolvedKey].push(this.items[index as never])\n            })\n        }\n\n        return new Collection(collection)\n    }\n\n    /**\n     * The has method determines if one or more keys exists in the collection.\n     */\n    has (...args: any[]): boolean {\n        const properties = variadic(args)\n\n        return properties.filter(key => Object.hasOwnProperty.call(this.items, key)).length\n            === properties.length\n    }\n\n\n    /**\n     * The implode method joins the items in a collection.\n     * Its arguments depend on the type of items in the collection.\n     *\n     * If the collection contains arrays or objects,\n     * you should pass the key of the attributes you wish to join,\n     * and the \"glue\" string you wish to place between the values.\n     */\n    implode<K> (key: keyof Item | K, glue?: string): string {\n        if (typeof glue === 'undefined' && Array.isArray(this.items)) {\n            return this.items.join(String(key))\n        }\n\n        return new Collection(this.items).pluck(key).all().join(glue)\n    }\n\n    /**\n     * The intersect method removes any values from the original collection\n     * that are not present in the given array or collection.\n     * The resulting collection will preserve the original collection's keys.\n     */\n    intersect (values: Item[] | Collection<Item>): Collection<Item> {\n        let intersectValues: Item[] = values as never\n\n        if (values instanceof Collection) {\n            intersectValues = values.all() as Item[]\n        }\n\n        const collection = this.items\n            .filter(item => intersectValues.indexOf(item) !== -1)\n\n        return new Collection(collection)\n    }\n\n\n    /**\n     * The intersectByKeys method removes any keys from the original collection\n     * that are not present in the given array or collection.\n     */\n    intersectByKeys<K extends keyof Item> (values: Item | Collection<Item>): Collection<K> {\n        let intersectKeys = Object.keys(values as never)\n\n        if (values instanceof this.constructor) {\n            intersectKeys = Object.keys(values.all())\n        }\n\n        const collection: GenericObj = {}\n\n        Object.keys(this.items).forEach((key) => {\n            if (intersectKeys.indexOf(key) !== -1) {\n                collection[key as never] = this.items[key as never] as never\n            }\n        })\n\n        return new Collection(collection) as never\n    }\n\n    /**\n     * The isEmpty method returns true if the collection is empty; otherwise, false is returned.\n     */\n    isEmpty (): boolean {\n        if (Array.isArray(this.items)) {\n            return !this.items.length\n        }\n\n        return !Object.keys(this.items).length\n    }\n\n\n    /**\n     * The isNotEmpty method returns true if the collection is not empty; otherwise, false is returned.\n     */\n    isNotEmpty (): boolean {\n        return !this.isEmpty()\n    }\n\n    /**\n     * Join the items in a callection with the provided glue\n     * \n     * @param glue \n     * @param finalGlue \n     * @returns \n     */\n    join (glue: string, finalGlue: string) {\n        const collection = this.values()\n\n        if (finalGlue === undefined) {\n            return collection.implode(glue)\n        }\n\n        const count = collection.count()\n\n        if (count === 0) {\n            return ''\n        }\n\n        if (count === 1) {\n            return collection.last()\n        }\n\n        const finalItem = collection.pop()\n\n        return collection.implode(glue) + finalGlue + finalItem\n    }\n\n    /**\n     * The keyBy method keys the collection by the given key.\n     * If multiple items have the same key, only the last one will appear in the new collection.\n     */\n    keyBy<T, K> (key: keyof Item | K | ((...args: any[]) => any)): Collection<T> {\n        const collection: GenericObj = {}\n\n        if (isFunction(key)) {\n            this.items.forEach((item) => {\n                collection[key(item)] = item\n            })\n        } else {\n            this.items.forEach((item) => {\n                const keyValue = nestedValue(item, key)\n\n                collection[keyValue || ''] = item\n            })\n        }\n\n        return new Collection(collection)\n    }\n\n\n    /**\n     * The keys method returns all of the collection's keys.\n     */\n    keys (): Collection<string> {\n        let collection = Object.keys(this.items)\n\n        if (Array.isArray(this.items)) {\n            collection = collection.map(Number) as never\n        }\n\n        return new Collection(collection)\n    }\n\n    /**\n     * The last method returns the last element in the collection that passes a given truth test.\n     */\n    last (fn?: (item: Item) => boolean, defaultValue?: any): Item {\n        let { items } = this\n\n        if (isFunction(fn)) {\n            items = this.filter(fn).all()\n        }\n\n        if ((Array.isArray(items) && !items.length) || (!Object.keys(items).length)) {\n            if (isFunction(defaultValue)) {\n                return defaultValue()\n            }\n\n            return defaultValue\n        }\n\n        if (Array.isArray(items)) {\n            return items[items.length - 1]\n        }\n        const keys = Object.keys(items)\n\n        return items[keys[keys.length - 1]]\n    }\n\n    /**\n     * The macro method lets you register custom methods.\n     */\n    macro (name: string, fn: (...args: any[]) => any): void {\n        this.constructor.prototype[name] = fn\n    }\n\n    /**\n     * The make method will make a new collection from nothing\n     * \n     * @param items \n     * @returns \n     */\n    make<T> (items = []): Collection<T> {\n        return new Collection<T>(items)\n    }\n\n    /**\n     * The map method iterates through the collection and passes each value to the given callback.\n     * The callback is free to modify the item and return it, thus forming a new collection of modified items.\n     */\n    map<T> (fn: (items: Item, index: any, key?: any) => T): Collection<T> {\n        if (Array.isArray(this.items)) {\n            return new Collection(this.items.map(fn))\n        }\n\n        const collection: GenericObj = {}\n\n        Object.entries(this.items).forEach(([key, value]) => {\n            collection[key] = fn(value as never, key)\n        })\n\n        return new Collection(collection)\n    }\n\n    /**\n     * The mapInto method iterates through the collection and instantiates the given class with each element as a constructor.\n     */\n    mapInto<T extends new (...args: any[]) => any> (ClassName: T): Collection<T> {\n        return this.map((value, key) => new ClassName(value, key))\n    }\n\n    mapSpread (fn: (...items: Item[]) => any) {\n        return this.map((values: any, key) => {\n            return fn(...values, key)\n        })\n    }\n\n    mapToDictionary (fn: (item: Item, index: any) => [any, any]): Collection<Item> {\n        const collection: GenericObj = {}\n\n        this.items.forEach((item, k) => {\n            const [key, value] = fn(item, k)\n\n            if (collection[key] === undefined) {\n                collection[key] = [value]\n            } else {\n                collection[key].push(value)\n            }\n        })\n\n        return new Collection<Item>(collection)\n    }\n\n    /**\n     * The mapToGroups method iterates through the collection and passes each value to the given callback.\n     */\n    mapToGroups (fn: (item: Item, key: string | number) => [any, any]): Collection<any> {\n        const collection: GenericObj = {}\n\n        this.items.forEach((item, key) => {\n            const [keyed, value] = fn(item, key)\n\n            if (collection[keyed] === undefined) {\n                collection[keyed] = [value]\n            } else {\n                collection[keyed].push(value)\n            }\n        })\n\n        return new Collection(collection)\n    }\n\n\n    /**\n     * The mapWithKeys method iterates through the collection and passes each value to the given callback.\n     * The callback should return an array where the first element represents the key\n     * and the second element represents the value pair.\n     */\n    mapWithKeys<T> (fn: (item: Item, index: number | string) => [string, any]): Collection<T> {\n        const collection: GenericObj = {}\n\n        if (Array.isArray(this.items)) {\n            this.items.forEach((item, index) => {\n                const [keyed, value] = fn(item, index)\n                collection[keyed] = value\n            })\n        } else {\n            Object.keys(this.items).forEach((key) => {\n                const [keyed, value] = fn(this.items[key as never], key)\n                collection[keyed] = value\n            })\n        }\n\n        return new Collection(collection)\n    }\n\n\n    /**\n     * The max method returns the maximum value of a given key.\n     */\n    max (key?: keyof Item | string): number {\n        if (typeof key === 'string') {\n            const filtered = this.items.filter(item => item[key as never] !== undefined)\n\n            return Math.max(...filtered.map(item => item[key as never]))\n        }\n\n        return Math.max(...this.items as any)\n    }\n\n\n    /**\n     * The median method returns the median value of a given key.\n     */\n    median<K> (key?: keyof Item | K): number {\n        const { length } = this.items\n\n        if (key === undefined) {\n            if (length % 2 === 0) {\n                return (this.items[(length / 2) - 1] as never + this.items[length / 2] as never) / 2\n            }\n\n            return this.items[Math.floor(length / 2)] as never\n        }\n\n        if (length % 2 === 0) {\n            return (this.items[(length / 2) - 1][key as never] + this.items[length / 2][key as never]) / 2\n        }\n\n        return this.items[Math.floor(length / 2)][key as never]\n    }\n\n    /**\n     * The merge method merges the given object into the original collection.\n     * If a key in the given object matches a key in the original collection,\n     * the given objects value will overwrite the value in the original collection.\n     * \n     * @param value \n     * @returns \n     */\n    merge<T> (value: GenericObj | T[]): Collection<T> {\n        let arrayOrObject: GenericObj = value\n\n        if (typeof arrayOrObject === 'string') {\n            arrayOrObject = [arrayOrObject]\n        }\n\n        if (Array.isArray(this.items) && Array.isArray(arrayOrObject)) {\n            return new Collection(this.items.concat(arrayOrObject)) as never\n        }\n\n        const collection = JSON.parse(JSON.stringify(this.items))\n\n        Object.keys(arrayOrObject).forEach((key) => {\n            collection[key] = arrayOrObject[key]\n        })\n\n        return new Collection<T>(collection)\n    }\n\n    /**\n     * The mergeRecursive method recursively merges the given object into the original collection.\n     * If a key in the given object matches a key in the original collection,\n     * the given objects value will overwrite the value in the original collection.\n     * \n     * @param items \n     * @returns \n     */\n    mergeRecursive (items: GenericObj | Collection): Collection<Item> {\n        const merge = (target: GenericObj, source: GenericObj) => {\n            const merged: GenericObj = {}\n\n            const mergedKeys = Object.keys({ ...target, ...source })\n\n            mergedKeys.forEach((key) => {\n                if (target[key] === undefined && source[key] !== undefined) {\n                    merged[key] = source[key]\n                } else if (target[key] !== undefined && source[key] === undefined) {\n                    merged[key] = target[key]\n                } else if (target[key] !== undefined && source[key] !== undefined) {\n                    if (target[key] === source[key]) {\n                        merged[key] = target[key]\n                    } else if (\n                        (!Array.isArray(target[key]) && typeof target[key] === 'object')\n                        && (!Array.isArray(source[key]) && typeof source[key] === 'object')\n                    ) {\n                        merged[key] = merge(target[key], source[key])\n                    } else {\n                        merged[key] = [].concat(target[key], source[key])\n                    }\n                }\n            })\n\n            return merged\n        }\n\n        if (!items) {\n            return this\n        }\n\n        if (items instanceof Collection) {\n            return new Collection(merge(this.items, items.all()))\n        }\n\n        return new Collection(merge(this.items, items))\n    }\n\n\n    /**\n     * The min method returns the minimum value of a given key.\n     */\n    min<K> (key?: keyof Item | K): number {\n        if (typeof key !== 'undefined') {\n            const filtered = this.items.filter(item => item[key as never] !== undefined)\n\n            return Math.min(...filtered.map(item => item[key as never]))\n        }\n\n        return Math.min(...this.items as any)\n    }\n\n\n    /**\n     * The mode method returns the mode value of a given key.\n     */\n    mode<K> (key?: keyof Item | K): Item[] | null {\n        const values: any[] = []\n        let highestCount = 1\n\n        if (!this.items.length) {\n            return null\n        }\n\n        this.items.forEach((item) => {\n            const tempValues = values.filter((value) => {\n                if (key !== undefined) {\n                    return value.key === item[key as never]\n                }\n\n                return value.key === item\n            })\n\n            if (!tempValues.length) {\n                if (key !== undefined) {\n                    values.push({ key: item[key as never], count: 1 })\n                } else {\n                    values.push({ key: item, count: 1 })\n                }\n            } else {\n                tempValues[0].count += 1\n                const { count } = tempValues[0]\n\n                if (count > highestCount) {\n                    highestCount = count\n                }\n            }\n        })\n\n        return values\n            .filter(value => value.count === highestCount)\n            .map(value => value.key)\n    }\n\n\n    /**\n     * The nth method creates a new collection consisting of every n-th element.\n     */\n    nth (n: number, offset?: number): Collection<Item> {\n        const items = getValues(this.items)\n\n        const collection = items\n            .slice(offset)\n            .filter((_, index) => index % n === 0)\n\n        return new Collection(collection)\n    }\n\n    /**\n     * The only method returns the items in the collection with the specified keys.\n     */\n    only<K> (...args: K[]): Collection<Item> {\n        const properties = variadic(args)\n\n        if (Array.isArray(this.items)) {\n            const collection = this.items\n                .filter(item => properties.indexOf(item) !== -1)\n\n            return new Collection(collection)\n        }\n\n        const collection: GenericObj = {}\n\n        Object.keys(this.items).forEach((prop) => {\n            if (properties.indexOf(prop) !== -1) {\n                collection[prop] = this.items[prop as never]\n            }\n        })\n\n        return new Collection(collection)\n    }\n\n    /**\n     * \n     * @param size \n     * @param value \n     * @returns \n     */\n    pad (size: number, value: number): Collection<Item> {\n        const abs = Math.abs(size)\n        const count = this.count()\n\n        if (abs <= count) {\n            return this\n        }\n\n        let diff = abs - count\n        const items = clone(this.items) as Item[]\n        const isArray = Array.isArray(this.items)\n        const prepend = size < 0\n\n        for (let iterator = 0; iterator < diff;) {\n            if (!isArray) {\n                if (typeof items[iterator] !== 'undefined') {\n                    diff += 1\n                } else {\n                    items[iterator] = value as never\n                }\n            } else if (prepend) {\n                items.unshift(value as never)\n            } else {\n                items.push(value as never)\n            }\n\n            iterator += 1\n        }\n\n        return new Collection<Item>(items)\n    }\n\n\n    /**\n     * The partition method may be combined with destructuring to separate elements\n     * that pass a given truth test from those that do not.\n     */\n    partition (fn: (item: Item) => boolean): [Item[], Item[]] {\n        let arrays: [Collection<Item>, Collection<Item>]\n\n        if (Array.isArray(this.items)) {\n            arrays = [new Collection<Item>([]), new Collection<Item>([])]\n\n            this.items.forEach((item) => {\n                if (fn(item) === true) {\n                    arrays[0].push(item)\n                } else {\n                    arrays[1].push(item)\n                }\n            })\n        } else {\n            arrays = [new Collection<Item>({}), new Collection<Item>({})]\n\n            Object.keys(this.items).forEach((prop) => {\n                const value = this.items[prop as never]\n\n                if (fn(value) === true) {\n                    arrays[0].put(prop, value)\n                } else {\n                    arrays[1].put(prop, value)\n                }\n            })\n        }\n\n        return new Collection(arrays) as never\n    }\n\n\n    /**\n     * The pipe method passes the collection to the given callback and returns the result.\n     */\n    pipe<U> (fn: (...any: any[]) => U): U {\n        return fn(this)\n    }\n\n    /**\n     * The pluck method retrieves all of the values for a given key.\n     */\n    pluck<T, K, V> (value: keyof Item | V, key?: keyof Item | K): Collection<T> {\n        if ((value as string).indexOf('*') !== -1) {\n            const keyPathMap = buildKeyPathMap(this.items as never)\n\n            const keyMatches: any[] = []\n\n            if (key !== undefined) {\n                const keyRegex = new RegExp(`0.${String(key)}`, 'g')\n                const keyNumberOfLevels = `0.${String(key)}`.split('.').length\n\n                Object.keys(keyPathMap).forEach((k) => {\n                    const matchingKey = k.match(keyRegex)\n\n                    if (matchingKey) {\n                        const match = matchingKey[0]\n\n                        if (match.split('.').length === keyNumberOfLevels) {\n                            keyMatches.push(keyPathMap[match])\n                        }\n                    }\n                })\n            }\n\n            const valueMatches: any[] = []\n            const valueRegex = new RegExp(`0.${value}`, 'g')\n            const valueNumberOfLevels = `0.${value}`.split('.').length\n\n\n            Object.keys(keyPathMap).forEach((k) => {\n                const matchingValue = k.match(valueRegex)\n\n                if (matchingValue) {\n                    const match = matchingValue[0]\n\n                    if (match.split('.').length === valueNumberOfLevels) {\n                        valueMatches.push(keyPathMap[match])\n                    }\n                }\n            })\n\n            if (key !== undefined) {\n                const collection: GenericObj = {}\n\n                this.items.forEach((item, index) => {\n                    collection[keyMatches[index as number] || ''] = valueMatches\n                })\n\n                return new Collection(collection) as never\n            }\n\n            return new Collection([valueMatches]) as never\n        }\n\n        if (key !== undefined) {\n            const collection: GenericObj = {}\n\n            this.items.forEach((item) => {\n                if (nestedValue(item, value) !== undefined) {\n                    collection[item[key as never] || ''] = nestedValue(item, value)\n                } else {\n                    collection[item[key as never] || ''] = null\n                }\n            })\n\n            return new Collection<Item>(collection) as never\n        }\n\n        return this.map((item) => {\n            if (nestedValue(item, value) !== undefined) {\n                return nestedValue(item, value)\n            }\n\n            return null\n        })\n    }\n\n    /**\n     * The pop method removes and returns the last item from the collection.\n     */\n    pop (count: number = 1): Item | Collection<Item> | undefined {\n        if (this.isEmpty()) {\n            return undefined\n        }\n\n        if (isArray(this.items)) {\n            if (count === 1) {\n                return this.items.pop()\n            }\n\n            return new Collection(this.items.splice(-count))\n        }\n\n        if (isObject(this.items)) {\n            const keys = Object.keys(this.items)\n\n            if (count === 1) {\n                const key = keys[keys.length - 1]\n                const last = this.items[key as never]\n\n                deleteKeys(this.items, key)\n\n                return last\n            }\n\n            const poppedKeys = keys.slice(-count)\n\n            const newObject = poppedKeys.reduce((acc, current) => {\n                acc[current] = this.items[current as never]\n\n                return acc\n            }, {} as GenericObj)\n\n            deleteKeys(this.items, poppedKeys)\n\n            return new Collection(newObject)\n        }\n\n        return undefined\n    }\n\n    /**\n     * The prepend method adds an item to the beginning of the collection.\n     */\n    prepend<K, V> (value: V, key?: K): this {\n        if (typeof key !== 'undefined') {\n            return this.put(key, value)\n        }\n\n        this.items.unshift(value as never)\n\n        return this\n    }\n\n    /**\n     * The pull method removes and returns an item from the collection by its key.\n     */\n    pull<K> (key: keyof Item | K, defaultValue?: any): Item | null {\n        let returnValue = this.items[key as never] || null\n\n        if (!returnValue && typeof defaultValue !== 'undefined') {\n            if (isFunction(defaultValue)) {\n                returnValue = defaultValue() as never\n            } else {\n                returnValue = defaultValue as never\n            }\n        }\n\n        delete this.items[key as never]\n\n        return returnValue\n    }\n\n\n    /**\n     * The push method appends an item to the end of the collection.\n     */\n    push (...items: Item[]): this {\n        this.items.push(...items)\n\n        return this\n    }\n\n    /**\n     * The put method sets the given key and value in the collection.\n     */\n    put<K, V> (key: K, value: V): this {\n        this.items[key as never] = value as never\n\n        return this\n    }\n\n    /**\n     * The random method returns a random item from the collection.\n     */\n    random (length?: number | string): Collection<Item> {\n        const items = getValues(this.items)\n\n        const collection = new Collection(items).shuffle()\n\n        // If not a length was specified\n        if (!length || length !== parseInt(String(length), 10)) {\n            return collection.first() as never\n        }\n\n        return collection.take(length)\n    }\n\n    /**\n     * The reduce method reduces the collection to a single value,\n     * passing the result of each iteration into the subsequent iteration.\n     */\n    reduce<T> (fn: (_carry?: T | null, item?: Item, index?: number | string) => T, carry?: T): any {\n        let reduceCarry: T | null | undefined = null\n\n        if (typeof carry !== 'undefined') {\n            reduceCarry = carry\n        }\n\n        if (Array.isArray(this.items)) {\n            this.items.forEach((item, index) => {\n                reduceCarry = fn(reduceCarry, item, index)\n            })\n        } else {\n            Object.keys(this.items).forEach((key) => {\n                reduceCarry = fn(reduceCarry, this.items[key as never], key)\n            })\n        }\n\n        return reduceCarry\n    }\n\n    /**\n     * The reject method filters the collection using the given callback.\n     * The callback should return true if the item should be removed from the resulting collection.\n     */\n    reject (fn: (item: Item) => boolean): Collection<Item> {\n        return new Collection(this.items).filter(item => !fn(item))\n    }\n\n    /**\n     * the replace method will replace matching properties in the collection\n     * \n     * @param items \n     * @returns \n     */\n    replace (items?: Item[] | Collection<Item> | GenericObj) {\n        if (!items) {\n            return this\n        }\n\n        if (Array.isArray(items)) {\n            const replaced = this.items.map((value, index) => items[index] || value)\n\n            return new Collection(replaced)\n        }\n\n        if (items instanceof Collection) {\n            const replaced = { ...this.items, ...items.all() }\n\n            return new Collection(replaced)\n        }\n\n        const replaced = { ...this.items, ...items }\n\n        return new Collection(replaced)\n    }\n\n    /**\n     * the replaceRecursive method will recursively replace matching properties in the collection\n     * \n     * @param items \n     * @returns \n     */\n    replaceRecursive (items: Item[] | Collection | GenericObj): Collection<Item> {\n\n        const replace = (target: GenericObj, source: GenericObj) => {\n            const replaced = { ...target }\n\n            const mergedKeys = Object.keys({ ...target, ...source })\n\n            mergedKeys.forEach((key) => {\n                if (!Array.isArray(source[key]) && typeof source[key] === 'object') {\n                    replaced[key] = replace(target[key], source[key])\n                } else if (target[key] === undefined && source[key] !== undefined) {\n                    if (typeof target[key] === 'object') {\n                        replaced[key] = { ...source[key] }\n                    } else {\n                        replaced[key] = source[key]\n                    }\n                } else if (target[key] !== undefined && source[key] === undefined) {\n                    if (typeof target[key] === 'object') {\n                        replaced[key] = { ...target[key] }\n                    } else {\n                        replaced[key] = target[key]\n                    }\n                } else if (target[key] !== undefined && source[key] !== undefined) {\n                    if (typeof source[key] === 'object') {\n                        replaced[key] = { ...source[key] }\n                    } else {\n                        replaced[key] = source[key]\n                    }\n                }\n            })\n\n            return replaced\n        }\n\n        if (!items) {\n            return this\n        }\n\n        if (!Array.isArray(items) && typeof items !== 'object') {\n            return new Collection<Item>(replace(this.items, [items]))\n        }\n\n        if (items instanceof Collection) {\n            return new Collection<Item>(replace(this.items, items.all()))\n        }\n\n        return new Collection<Item>(replace(this.items, items))\n    }\n\n\n    /**\n     * The reverse method reverses the order of the collection's items.\n     */\n    reverse (): Collection<Item> {\n        const collection = Array.isArray(this.items)\n            ? ([] as Item[]).concat(this.items).reverse()\n            : Object.fromEntries(Object.entries(this.items).reverse())\n\n        return new Collection(collection) as never\n    }\n\n\n    /**\n     * The search method searches the collection for the given value and returns its key if found.\n     * If the item is not found, false is returned.\n     */\n    search (valueOrFunction: Item | ((value: Item, key: number) => boolean), strict?: boolean): any {\n        let result: number | undefined = undefined\n\n        const find = (_: any, key: number) => {\n            if (isFunction(valueOrFunction)) {\n                return valueOrFunction(this.items[key as never], key)\n            }\n\n            if (strict) {\n                return this.items[key as never] === valueOrFunction\n            }\n\n            return this.items[key as never] == valueOrFunction\n        }\n\n        if (isArray(this.items)) {\n            result = this.items.findIndex(find)\n        } else if (isObject(this.items)) {\n            result = Object.keys(this.items).find(key => find(this.items[key as never], key as never)) as never\n        }\n\n        if (typeof result === 'undefined' || result < 0) {\n            return false\n        }\n\n        return result\n    }\n\n    /**\n     * The shift method removes and returns the first item from the collection.\n     */\n    shift (count = 1): Collection<Item> | undefined {\n        if (this.isEmpty()) {\n            return undefined\n        }\n\n        if (isArray(this.items)) {\n            if (count === 1) {\n                return this.items.shift() as never\n            }\n\n            return new Collection<Item>(this.items.splice(0, count))\n        }\n\n        if (isObject(this.items)) {\n            if (count === 1) {\n                const key = Object.keys(this.items)[0]\n                const value = this.items[key as never]\n                delete this.items[key as never]\n\n                return value as never\n            }\n\n            const keys = Object.keys(this.items)\n            const poppedKeys = keys.slice(0, count)\n\n            const newObject = poppedKeys.reduce((acc, current) => {\n                acc[current] = this.items[current as never]\n\n                return acc\n            }, {} as GenericObj)\n\n            deleteKeys(this.items, poppedKeys)\n\n            return new Collection<Item>(newObject)\n        }\n\n        return undefined\n    }\n\n\n    /**\n     * The shuffle method randomly shuffles the items in the collection.\n     */\n    shuffle (): this {\n        const items = getValues(this.items)\n\n        let j\n        let x\n        let i\n\n        for (i = items.length; i; i -= 1) {\n            j = Math.floor(Math.random() * i)\n            x = items[i - 1]\n            items[i - 1] = items[j]\n            items[j] = x\n        }\n\n        this.items = items\n\n        return this\n    }\n\n    /**\n     * \n     * @param number \n     * @returns \n     */\n    skip (number: number): Collection<Item> {\n        if (isObject(this.items)) {\n            return new Collection<Item>(\n                Object.keys(this.items)\n                    .reduce((accumulator, key, index) => {\n                        if ((index + 1) > number) {\n                            accumulator[key] = this.items[key as never]\n                        }\n\n                        return accumulator\n                    }, {} as GenericObj),\n            )\n        }\n\n        return new Collection<Item>(this.items.slice(number))\n    }\n\n    /**\n     * \n     * @param valueOrFunction \n     * @returns \n     */\n    skipUntil<K> (valueOrFunction: Item | K | ((value: Item) => boolean)): Collection<Item> {\n        let previous: boolean | null = null\n        let items\n\n        let callback: (v: Item) => any = value => value === valueOrFunction\n\n        if (isFunction(valueOrFunction)) {\n            callback = valueOrFunction\n        }\n\n        if (isArray(this.items)) {\n            items = this.items.filter((item) => {\n                if (previous !== true) {\n                    previous = callback(item)\n                }\n\n                return previous\n            })\n        }\n\n        if (isObject(this.items)) {\n            items = Object.keys(this.items).reduce((acc, key) => {\n                if (previous !== true) {\n                    previous = callback(this.items[key as never])\n                }\n\n                if (previous !== false) {\n                    acc[key] = this.items[key as never]\n                }\n\n                return acc\n            }, {} as GenericObj)\n        }\n\n        return new Collection<Item>(items)\n    }\n\n    /**\n     * \n     * @param valueOrFunction \n     * @returns \n     */\n    skipWhile (valueOrFunction: Item | ((value: Item) => boolean)): Collection<Item> {\n        let previous: boolean | null = null\n        let items\n\n        let callback: (v: Item) => any = value => value === valueOrFunction\n\n        if (isFunction(valueOrFunction)) {\n            callback = valueOrFunction\n        }\n\n        if (isArray(this.items)) {\n            items = this.items.filter((item) => {\n                if (previous !== true) {\n                    previous = !callback(item)\n                }\n\n                return previous\n            })\n        }\n\n        if (isObject(this.items)) {\n            items = Object.keys(this.items).reduce((acc, key) => {\n                if (previous !== true) {\n                    previous = !callback(this.items[key as never])\n                }\n\n                if (previous !== false) {\n                    acc[key] = this.items[key as never]\n                }\n\n                return acc\n            }, {} as GenericObj)\n        }\n\n        return new Collection<Item>(items)\n    }\n\n    /**\n     * The slice method returns a slice of the collection starting at the given index.\n     */\n    slice (remove: number, limit?: number): Collection<Item> {\n        let collection = this.items.slice(remove)\n\n        if (typeof limit !== 'undefined') {\n            collection = collection.slice(0, limit)\n        }\n\n        return new Collection(collection)\n    }\n\n    sole<K, V> (key?: keyof Item | K | ((val: Item) => any), operator?: Operator | K, value?: V) {\n        let collection\n\n        if (isFunction(key)) {\n            collection = this.filter(key)\n        } else {\n            collection = this.where(key, operator, value)\n        }\n\n        if (collection.isEmpty()) {\n            throw new Error('Item not found.')\n        }\n\n        if (collection.count() > 1) {\n            throw new Error('Multiple items found.')\n        }\n\n        return collection.first()\n    }\n\n    /**\n     * The some method determines whether the collection contains a given item.\n     * \n     * @param key \n     * @param value \n     * @alias contains\n     * @returns \n     */\n    some<V> (key: keyof Item | ((...args: any[]) => any), value?: V): boolean {\n        return this.contains(key, value)\n    }\n\n    /**\n     * The sort method sorts the collection.\n     */\n    sort (fn?: (a: Item, b: Item) => number): Collection<Item> {\n        const collection = [].concat(this.items as never)\n\n        if (typeof fn === 'undefined') {\n            if (this.every(item => typeof item === 'number')) {\n                collection.sort((a, b) => a - b)\n            } else {\n                collection.sort()\n            }\n        } else {\n            collection.sort(fn)\n        }\n\n        return new Collection<Item>(collection)\n    }\n\n    /**\n     * The sortBy method sorts the collection by the given key.\n     * The sorted collection keeps the original array keys.\n     */\n    sortBy<V> (value: V): Collection<Item>\n    /**\n     * The sortBy method sorts the collection by the given callback.\n     * The sorted collection keeps the original array keys.\n     */\n    sortBy (fn: (item: Item) => number): Collection<Item>\n    /**\n     * The sortByMany method sorts the collection by the given keys.\n     * The sorted collection keeps the original array keys.\n     */\n    sortBy<V> (keys: V[]): Collection<Item>\n    /**\n     * The sortByMany method sorts the collection by the given callbacks.\n     * The sorted collection keeps the original array keys.\n     */\n    sortBy (fns: ((item: Item) => number)[]): Collection<Item>\n    /**\n     * The sortBy method sorts the collection by the given callback.\n     * The sorted collection keeps the original array keys.\n     */\n    sortBy (fn: (item: Item) => number): Collection<Item>\n    sortBy<V> (key: V[] | ((item: Item) => number)): Collection<Item>\n    sortBy<V> (key: V[] | ((item: Item) => number)): Collection<Item> {\n        if (isArray(key)) {\n            return this.sortByMany(key)\n        }\n\n        const collection = [].concat(this.items as never)\n        const getValue = (item: never) => {\n            if (isFunction(key)) {\n                return key(item)\n            }\n\n            return nestedValue(item, key)\n        }\n\n        collection.sort((a, b) => {\n            const valueA = getValue(a)\n            const valueB = getValue(b)\n\n            if (valueA === null || valueA === undefined) {\n                return 1\n            }\n            if (valueB === null || valueB === undefined) {\n                return -1\n            }\n\n            if (valueA < valueB) {\n                return -1\n            }\n            if (valueA > valueB) {\n                return 1\n            }\n\n            return 0\n        })\n\n        return new Collection<Item>(collection)\n    }\n\n    /**\n     * This method has the same signature as the sortBy method,\n     * but will sort the collection in the opposite order.\n     */\n    sortByDesc<V> (value: V): Collection<Item>\n    /**\n     * This method has the same signature as the sortBy method,\n     * but will sort the collection in the opposite order.\n     */\n    sortByDesc (fn: (item: Item) => number): Collection<Item>\n    sortByDesc (fn: (item: Item) => number): Collection<Item> {\n        return this.sortBy(fn).reverse()\n    }\n\n    /**\n     * The sortByMany method sorts the collection by the given callbacks.\n     * The sorted collection keeps the original array keys.\n     */\n    sortByMany<V> (value: (V | (() => any))[]): Collection<Item> {\n        const getValue = (item: any, valueOrFunction: any) => {\n            if (isFunction(valueOrFunction)) {\n                return valueOrFunction(item)\n            }\n\n            return nestedValue(item, valueOrFunction)\n        }\n\n\n        const collection = [].concat(this.items as never)\n\n        collection.sort((a, b) => {\n            for (let index = 0; index < value.length; index += 1) {\n                const criteria = value[index]\n\n                const valueA = getValue(a, criteria)\n                const valueB = getValue(b, criteria)\n\n                if (valueA === null || valueA === undefined) {\n                    return 1\n                }\n                if (valueB === null || valueB === undefined) {\n                    return -1\n                }\n\n                if (valueA < valueB) {\n                    return -1\n                }\n                if (valueA > valueB) {\n                    return 1\n                }\n            }\n\n            return 0\n        })\n\n        return new Collection<Item>(collection)\n    }\n\n    /**\n     * \n     * @returns \n     */\n    sortDesc () {\n        return this.sort().reverse()\n    }\n\n    sortKeys (): Collection<Item> {\n        const ordered: GenericObj = {}\n\n        Object.keys(this.items).sort().forEach((key) => {\n            ordered[key] = this.items[key as never]\n        })\n\n        return new Collection<Item>(ordered)\n    }\n\n    /**\n     * \n     * @returns \n     */\n    sortKeysDesc (): Collection<Item> {\n        const ordered: GenericObj = {}\n\n        Object.keys(this.items).sort().reverse().forEach((key) => {\n            ordered[key] = this.items[key as never]\n        })\n\n        return new Collection<Item>(ordered)\n    }\n\n    /**\n     * The splice method removes and returns a slice of items starting at the specified index.\n     * You may pass a second argument to limit the size of the resulting chunk.\n     */\n    splice (index: number, limit: number, replace?: Item[]): Collection<Item> {\n        const slicedCollection = this.slice(index, limit)\n\n        this.items = this.diff(slicedCollection.all() as never).all()\n\n        if (Array.isArray(replace)) {\n            for (let iterator = 0, { length } = replace;\n                iterator < length; iterator += 1) {\n                this.items.splice(index + iterator, 0, replace[iterator])\n            }\n        }\n\n        return slicedCollection\n    }\n\n\n    /**\n     * The split method breaks a collection into the given number of groups.\n     */\n    split (numberOfGroups: number): Collection {\n        const itemsPerGroup = Math.round(this.items.length as number / numberOfGroups)\n\n        const items = JSON.parse(JSON.stringify(this.items))\n        const collection = []\n\n        for (let iterator = 0; iterator < numberOfGroups; iterator += 1) {\n            collection.push(new Collection(items.splice(0, itemsPerGroup)))\n        }\n\n        return new Collection(collection)\n    }\n\n    /**\n     * The sum method returns the sum of all items in the collection.\n     */\n    sum<K> (key?: keyof Item | K | ((item: Item) => number | string)): number {\n        const items = getValues(this.items)\n\n        let total = 0\n\n        if (key === undefined) {\n            for (let i = 0, { length } = items; i < length; i += 1) {\n                total += parseFloat(items[i])\n            }\n        } else if (isFunction(key)) {\n            for (let i = 0, { length } = items; i < length; i += 1) {\n                total += parseFloat(String(key(items[i])))\n            }\n        } else {\n            for (let i = 0, { length } = items; i < length; i += 1) {\n                total += parseFloat(items[i][key])\n            }\n        }\n\n\n        return parseFloat(total.toPrecision(12))\n    }\n\n    /**\n     * The take method returns a new collection with the specified number of items:\n     * You may also pass a negative integer to take the specified amount of items from the end of the collection.\n     */\n    take (length: number): Collection<Item> {\n        if (!Array.isArray(this.items) && typeof this.items === 'object') {\n            const keys = Object.keys(this.items)\n            let slicedKeys\n\n            if (length < 0) {\n                slicedKeys = keys.slice(length)\n            } else {\n                slicedKeys = keys.slice(0, length)\n            }\n\n            const collection: GenericObj = {}\n\n            keys.forEach((prop) => {\n                if (slicedKeys.indexOf(prop) !== -1) {\n                    collection[prop] = this.items[prop as never]\n                }\n            })\n\n            return new Collection(collection)\n        }\n\n        if (length < 0) {\n            return new Collection(this.items.slice(length))\n        }\n\n        return new Collection(this.items.slice(0, length))\n    }\n\n    /**\n     * \n     * @param valueOrFunction \n     * @returns \n     */\n    takeUntil (valueOrFunction: Item | ((value: Item) => boolean)): Collection<Item> {\n        let previous: boolean | null = null\n        let items\n\n        let callback: (v: Item) => any = value => value === valueOrFunction\n\n        if (isFunction(valueOrFunction)) {\n            callback = valueOrFunction\n        }\n\n        if (isArray(this.items)) {\n            items = this.items.filter((item) => {\n                if (previous !== false) {\n                    previous = !callback(item)\n                }\n\n                return previous\n            })\n        }\n\n        if (isObject(this.items)) {\n            items = Object.keys(this.items).reduce((acc, key) => {\n                if (previous !== false) {\n                    previous = !callback(this.items[key as never])\n                }\n\n                if (previous !== false) {\n                    acc[key] = this.items[key as never]\n                }\n\n                return acc\n            }, {} as GenericObj)\n        }\n\n        return new Collection<Item>(items)\n    }\n\n\n    /**\n     * \n     * @param valueOrFunction \n     * @returns \n     */\n    takeWhile (valueOrFunction: Item | ((value: Item) => boolean)): Collection<Item> {\n        let previous: boolean | null = null\n        let items\n\n        let callback: (v: Item) => any = value => value === valueOrFunction\n\n        if (isFunction(valueOrFunction)) {\n            callback = valueOrFunction\n        }\n\n        if (isArray(this.items)) {\n            items = this.items.filter((item) => {\n                if (previous !== false) {\n                    previous = callback(item)\n                }\n\n                return previous\n            })\n        }\n\n        if (isObject(this.items)) {\n            items = Object.keys(this.items).reduce((acc, key) => {\n                if (previous !== false) {\n                    previous = callback(this.items[key as never])\n                }\n\n                if (previous !== false) {\n                    acc[key] = this.items[key as never]\n                }\n\n                return acc\n            }, {} as GenericObj)\n        }\n\n        return new Collection<Item>(items)\n    }\n\n\n    /**\n     * The tap method passes the collection to the given callback,\n     * allowing you to \"tap\" into the collection at a specific point\n     * and do something with the items while not affecting the collection itself.\n     */\n    tap (fn: (collection: Collection<Item>) => void): this {\n        fn(this)\n\n        return this\n    }\n\n    /**\n     * The times method creates a new collection by invoking the callback a given amount of times.\n     */\n    times (times: number, fn: (time: number) => any): this {\n        for (let iterator = 1; iterator <= times; iterator += 1) {\n            this.items.push(fn(iterator))\n        }\n\n        return this\n    }\n\n    /**\n     * The toArray method converts the collection into a plain array.\n     * If the collection is an object, an array containing the values will be returned.\n     */\n    toArray (): Item[] {\n        function iterate (list: Collection | any[], collection: any[]) {\n            const childCollection: any[] = []\n\n            if (list instanceof Collection) {\n                list.items.forEach((i: Collection | any[]) => iterate(i, childCollection))\n                collection.push(childCollection)\n            } else if (Array.isArray(list)) {\n                list.forEach(i => iterate(i, childCollection))\n                collection.push(childCollection)\n            } else {\n                collection.push(list)\n            }\n        }\n\n        if (Array.isArray(this.items)) {\n            const collection: any[] = []\n\n            this.items.forEach((items: any) => {\n                iterate(items, collection)\n            })\n\n            return collection\n        }\n\n        return this.values().all() as never\n    }\n\n\n    /**\n     * The toJson method converts the collection into JSON string.\n     */\n    toJson (): string {\n        if (typeof this.items === 'object' && !Array.isArray(this.items)) {\n            return JSON.stringify(this.all())\n        }\n\n        return JSON.stringify(this.toArray())\n    }\n\n    protected toJSON () {\n        return this.items\n    }\n\n    /**\n     * The transform method iterates over the collection and calls the given callback with each item in the collection.\n     * The items in the collection will be replaced by the values returned by the callback.\n     */\n    transform<T> (fn: (item: Item, key?: number) => T): this {\n        if (Array.isArray(this.items)) {\n            this.items = this.items.map(fn) as never\n        } else {\n            const collection: GenericObj = {}\n\n            Object.keys(this.items).forEach((key) => {\n                collection[key] = fn(this.items[key as never], key as never)\n            })\n\n            this.items = collection as never\n        }\n\n        return this\n    }\n\n\n    /**\n     * The union method adds the given array to the collection.\n     * If the given array contains keys that are already in the original collection,\n     * the original collection's values will be preferred.\n     */\n    union<T> (object: GenericObj): Collection<T> {\n        const collection: GenericObj = JSON.parse(JSON.stringify(this.items))\n\n        Object.keys(object).forEach((prop) => {\n            if (this.items[prop as never] === undefined) {\n                collection[prop] = object[prop]\n            }\n        })\n\n        return new Collection(collection)\n    }\n\n\n    /**\n     * The unique method returns all of the unique items in the collection.\n     */\n    unique<K> (key?: keyof Item | K | ((...args: any[]) => any)): Collection<Item> {\n        let collection: Collection<Item> | Item[]\n\n        if (key === undefined) {\n            collection = this.items\n                .filter((element, index, self) => self.indexOf(element) === index)\n        } else {\n            collection = []\n\n            const usedKeys = []\n\n            for (let iterator = 0, { length } = this.items; iterator < (length as number); iterator += 1) {\n                let uniqueKey\n                if (isFunction(key)) {\n                    uniqueKey = key(this.items[iterator as never])\n                } else {\n                    uniqueKey = this.items[iterator as never][key as never]\n                }\n\n                if (usedKeys.indexOf(uniqueKey) === -1) {\n                    collection.push(this.items[iterator as never])\n                    usedKeys.push(uniqueKey)\n                }\n            }\n        }\n\n        return new Collection<Item>(collection as never)\n    }\n\n\n    /**\n     * The unless method will execute the given callback when the first argument given to the method evaluates to false.\n     */\n    unless (\n        condition: boolean,\n        fn: (collection: Collection<Item>) => Collection<Item>,\n        defaultFn?: (collection: Collection<Item>) => Collection<Item>\n    ): Collection<Item> {\n        if (!condition) {\n            return fn(this)\n        } else if (defaultFn) {\n            return defaultFn(this)\n        }\n\n        return this\n    }\n\n    /**\n     * The unwrap method will unwrap the given collection.\n     */\n    unwrap<T> (value: T[] | Collection<T>): T[] {\n        if (value instanceof Collection) {\n            return value.all() as never\n        }\n\n        return value\n    }\n\n    /**\n     * The values method returns a new collection with the keys reset to consecutive integers.\n     */\n    values<T> (): Collection<T> {\n        return new Collection(getValues(this.items))\n    }\n\n    /**\n     * \n     * @returns \n     */\n    undot (): Collection<Item> {\n        if (Array.isArray(this.items)) {\n            return this\n        }\n\n        let collection: GenericObj = {}\n\n        Object.keys(this.items).forEach((key) => {\n            if (key.indexOf('.') !== -1) {\n                const obj = collection\n\n                key.split('.').reduce((acc, current, index, array) => {\n                    if (!acc[current]) {\n                        acc[current] = {}\n                    }\n\n                    if ((index === array.length - 1)) {\n                        acc[current] = this.items[key as never]\n                    }\n\n                    return acc[current]\n                }, obj)\n\n                collection = { ...collection, ...obj }\n            } else {\n                collection[key] = this.items[key as never]\n            }\n        })\n\n        return new Collection<Item>(collection)\n    }\n\n    /**\n     * Run the given callback if the result is empty\n     * @param fn \n     * @param defaultFn \n     * @alias whenEmpty\n     * \n     * @returns \n     */\n    unlessEmpty (\n        fn: (collection: Collection<Item>) => Collection<Item>,\n        defaultFn?: (collection: Collection<Item>) => Collection<Item>\n    ) {\n        return this.whenNotEmpty(fn, defaultFn)\n    }\n\n    /**\n     * Run the given callback if the result is empty\n     * @param fn \n     * @param defaultFn \n     * @alias whenEmpty\n     * \n     * @returns \n     */\n    unlessNotEmpty (\n        fn: (collection: Collection<Item>) => Collection<Item>,\n        defaultFn?: (collection: Collection<Item>) => Collection<Item>\n    ) {\n        return this.whenEmpty(fn, defaultFn)\n    }\n\n    /**\n     * The when method will execute the given callback when the first argument given to the method evaluates to true.\n     */\n    when (\n        condition: boolean,\n        fn: (collection: Collection<Item>, condition?: boolean) => Collection<Item>,\n        defaultFn?: (collection: Collection<Item>, condition?: boolean) => Collection<Item>\n    ): Collection<Item> {\n        if (condition) {\n            return fn(this, condition)\n        }\n\n        if (defaultFn) {\n            return defaultFn(this, condition)\n        }\n\n        return this\n    }\n\n    /**\n     * Run the given callback if the result is empty\n     * @param fn \n     * @param defaultFn \n     * @returns \n     */\n    whenEmpty (\n        fn: (collection: Collection<Item>) => Collection<Item>,\n        defaultFn?: (collection: Collection<Item>) => Collection<Item>\n    ) {\n        if (Array.isArray(this.items) && !this.items.length) {\n            return fn(this)\n        } if (!Object.keys(this.items).length) {\n            return fn(this)\n        }\n\n        if (defaultFn !== undefined) {\n            if (Array.isArray(this.items) && this.items.length) {\n                return defaultFn(this)\n            } if (Object.keys(this.items).length) {\n                return defaultFn(this)\n            }\n        }\n\n        return this\n    }\n\n    /**\n     * Run the given callback if the result is not empty\n     * @param fn \n     * @param defaultFn \n     * @returns \n     */\n    whenNotEmpty (\n        fn: (collection: Collection<Item>) => Collection<Item>,\n        defaultFn?: (collection: Collection<Item>) => Collection<Item>\n    ) {\n        if (Array.isArray(this.items) && this.items.length) {\n            return fn(this)\n        } if (Object.keys(this.items).length) {\n            return fn(this)\n        }\n\n        if (defaultFn !== undefined) {\n            if (Array.isArray(this.items) && !this.items.length) {\n                return defaultFn(this)\n            } if (!Object.keys(this.items).length) {\n                return defaultFn(this)\n            }\n        }\n\n        return this\n    }\n\n    /**\n     * The where method filters the collection by a given key / value pair.\n    */\n    where<K, V> (key: keyof Item | K, value: V): Collection<Item>\n    where<K, V> (key?: keyof Item | K, operator?: Operator | K, value?: V | null | undefined): Collection<Item>\n    where<K, V> (key?: keyof Item | K, operator?: Operator | K, value?: V | null | undefined): Collection<Item> {\n        let comparisonOperator = operator\n        let comparisonValue: Operator | V | K = value!\n\n        const items = getValues(this.items)\n\n        if (key === undefined && operator === undefined) {\n            return new Collection(items.filter(item => !!item))\n        }\n\n        if (operator === undefined || operator === true) {\n            return new Collection(items.filter(item => nestedValue(item, String(key))))\n        }\n\n        if (operator === false) {\n            return new Collection(items.filter(item => !nestedValue(item, String(key))))\n        }\n\n        if (value === undefined) {\n            comparisonValue = operator\n            comparisonOperator = '==='\n        }\n\n        const collection = items.filter((item) => {\n            switch (comparisonOperator) {\n                case '==':\n                    return nestedValue(item, String(key)) === Number(comparisonValue)\n                        || nestedValue(item, String(key)) == comparisonValue\n\n                default:\n                case '===':\n                    return nestedValue(item, String(key)) === comparisonValue\n\n                case '!=':\n                case '<>':\n                    return nestedValue(item, String(key)) !== Number(comparisonValue)\n                        && nestedValue(item, String(key)) != comparisonValue\n\n                case '!==':\n                    return nestedValue(item, String(key)) !== comparisonValue\n\n                case '<':\n                    return nestedValue(item, String(key)) < comparisonValue\n\n                case '<=':\n                    return nestedValue(item, String(key)) <= comparisonValue\n\n                case '>':\n                    return nestedValue(item, String(key)) > comparisonValue\n\n                case '>=':\n                    return nestedValue(item, String(key)) >= comparisonValue\n            }\n        })\n\n        return new Collection(collection)\n    }\n\n    /**\n     * \n     * The whereBetween method filters the collection by a key value range.\n     * \n     * @param key \n     * @param values \n     * @returns \n     */\n    whereBetween<K, V> (key: keyof Item | K, values: V[]): Collection<Item> {\n        return this.where(key, '>=', values[0]).where(key, '<=', values[values.length - 1])\n    }\n\n    /**\n     * The whereIn method filters the collection by a given key / value contained within the given array.\n     */\n    whereIn<K, V> (key: keyof Item | K, values: V[]): Collection<Item> {\n        const items = getValues(values)\n\n        const collection = this.items\n            .filter(item => items.indexOf(nestedValue(item, String(key))) !== -1)\n\n        return new Collection(collection)\n    }\n\n    /**\n     * \n     * @param type \n     * @returns \n     */\n    whereInstanceOf (type: abstract new (...args: any[]) => any) {\n        return this.filter(item => item instanceof type)\n    }\n\n    /**\n     * \n     * The whereNotBetween method filters the collection by a given key / value not contained within the given arguements.\n     * \n     * @param key \n     * @param values \n     * @returns \n     */\n    whereNotBetween<K, V> (key: keyof Item | K, values: V[]): Collection<Item> {\n        return this.filter(item => (\n            nestedValue(item, key as string) < values[0] || nestedValue(item, key as string) > values[values.length - 1]\n        ))\n    }\n\n    /**\n     * The whereNotIn method filters the collection by a given key / value not contained within the given array.\n     */\n    whereNotIn<K, V> (key: keyof Item | K, values: V[]): Collection<Item> {\n        const items = getValues(values)\n\n        const collection = this.items\n            .filter(item => items.indexOf(nestedValue(item, String(key))) === -1)\n\n        return new Collection(collection)\n    }\n\n    /**\n     * Filter only items in the collectino that do not have null values\n     * \n     * @param key \n     * @returns \n     */\n    whereNotNull (key?: keyof Item) {\n        return this.where(key, '!==', null)\n    }\n\n    /**\n     * The whereNull method filters items where the given key is null.\n     * \n     * @param key \n     * @returns \n     */\n    whereNull<K> (key: keyof Item | K | null | undefined = null) {\n        return this.where(key, '===', null)\n    }\n\n    /**\n     * The wrap method will wrap the given value in a collection.\n     */\n    wrap<T> (value: T | T[] | Collection<T>): Collection<T> {\n        if (value instanceof Collection) {\n            return value\n        }\n\n        if (typeof value === 'object') {\n            return new Collection(value)\n        }\n\n        return new Collection([value])\n    }\n\n    /**\n     * The zip method merges together the values of the given array with the values\n     * of the original collection at the corresponding index.\n     */\n    zip<T> (array: T[] | Collection): Collection<[Item, T]> {\n        const items = Array.isArray(this.items) ? this.items : Object.values(this.items)\n        let values = array\n\n        if (values instanceof Collection) {\n            values = values.all() as never\n        }\n\n        const collection = items.map((item, index) => new Collection([item, values[index as never]]))\n\n        return new Collection<[Item, T]>(collection as never)\n    }\n\n    [Symbol.iterator] (): Iterator<Item> {\n        let index = -1\n        const items: any = this.items\n        const length = Array.isArray(this.items) ? this.items.length : Object.keys(this.items).length\n\n        return {\n            next: () => {\n                index += 1\n\n                return {\n                    value: items[index],\n                    done: index >= length,\n                }\n            },\n        }\n    }\n}\n\nexport const collect = <Item = any> (collection?: Record<string, Item> | Item[] | Item) => new Collection(collection)"],"mappings":"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"}